Topic: Graph Theory and its Implementation in Board Games
Group Members:
Ibrahim Butt 24043
Muhammad Tahir Ahmad 24151
Ammara Khan 24133
Sara Abid 24112
Israr Hussain 24025


GRAPH: A list of pairs of ‚Äúthings‚Äù called vertex/vertices, and lines between those points, called edges.
ùê¥ = {(1, 2), (1, 3), (3, 4), (4, 5)} 
ùêµ = {(A, B), (B, C), (A, C), (A, D)} 
ùê∂ = {(LHR, KRA), (LHR, ISB), (FSD, SWL), (STD, MUL)}


Total Edges: (n(n-1))/2


Difference Between Undirected Graphs and Directed Gaphs:
A directed graph is a graph where the edges have a direction, meaning each edge connects an ordered pair of vertices.
An undirected graph is a graph where the edges have no direction, connecting pairs of vertices without any order.


Weighted Graphs
Many graphs can have edges that contain a certain weight to represent an arbitrary value such as cost, distance, quantity,  etc.
This suggests that all edges cannot be treated equally in certain cases.
USE IN GAME:
to represent the potential impact or strategic value of certain moves.
Weights could represent how close a sequence is to completion
In more advanced AI implementations, weighted graphs can help find paths that maximize player's advantage while minimizing the opponent‚Äôs.


Connected Graphs vs Disconnected Graphs
Connected Graphs
A graph is called connected when a path exist between all of its vertices.
Disconnected Graphs
A graph is called connected when a path doesn‚Äôt exist between all of its vertices.


Graph Representation:

Edge List
Individual track of all edges
Need to check all edges

Adjacency List
Track of all adjacent to a particular edge
Need to check relevant list of adjacent 

Adjacency Matrix
Table in form of rows and columns that keep track of all possible edges in terms of YES/NO
Only need to check one cell.


Things we need for our area of research:
How to traverse a graph
Count neighbors of a vertex
Count degree of a vertex(number of edges meeting at that vertex)
Deleting and inserting edges
Path and cycle of vertices


Graph in Board Games
Most board games are played on a two-dimensional grid. 
- Nodes represent the cells where game pieces are placed. 
- Winning conditions involve finding paths (edges) with consecutive stones.


Implementation
Topics like graph theory, and recursion play crucial roles in modeling and solving the game.

Graph coloring in board games
Involves assigning different colors to the vertices of a graph such that no two adjacent vertices share the same color.
Simplifies game design by managing player interactions and organizing regions.
- Territory Colouring:  Assigning different colours to neighbouring territories.
- Player moves: Useful in multiplayer games to minimize conflicts.
- Puzzle Solving: No two adjacent players have the same colours.


Graph Coloring in Board Games:
involves assigning different colors to the vertices of a graph such that no two adjacent vertices share the same color.
Simplifies game design by managing player interactions and organizing regions.

Territory Colouring:  Assigning different colours to neighbouring territories.
Player moves: Useful in multiplayer games to minimize conflicts.
Puzzle Solving: No two adjacent players have the same colours.


Trees and Spanning Trees
Tree is a simple, connected ,undirected ,acyclic(having  a unique path between any two vertices) graph.

A spanning tree of a graph is a subgraph that includes all vertices of the graph and is a tree.
- Spanning trees connect all vertices with the minimum possible edges.

In games, spanning trees can help create unique paths with no loops.



Path Finding:
Definition:
	‚ÄúPathfinding refers to the process of finding a path from one point (vertex) to another in a graph.‚Äù

A path in a graph is a sequence of edges that connects a series of vertices.
It can be represented as a list of vertices starting from a source node and ending at a destination node, with each consecutive vertex connected by an edge.


Shortest Path:
Definition:
	‚ÄúThe shortest path is a path between two vertices such that the sum of the weights of the edges in the path is minimized.‚Äù

In unweighted graphs, the shortest path is simply the path with the least number of edges.
In weighted graphs, it‚Äôs the path with the minimum total weight.


Some Algorithms used for Path Finding
Dijkstra‚Äôs Algorithm
A* Algorithm
Bellman-Ford Algorithm
Floyd-Warshall Algorithm
Breadth-First Search (BFS)
Depth-First Search (DFS)
Johnson‚Äôs Algorithm

We have used Breadth-First Search (BFS) in our code..

Breadth-First Search Algorithm (BFS)
BFS is the best algorithm used for path finding in unweighted graphs.

Recursion :
recursion is a process or a concept in terms of a simpler or previous version of itself.
‚Ä¢ BASE CASE:
 a condition that allows an algorithm stops 
further recursive calls and return a result.
‚Ä¢ Recursive case:
 It is the part of a recursive function that 
breaks down a problem into smaller 
subproblems, which moves the problem closer 
to the base case.

HOW RECURSION WORKS:
‚Ä¢ Step By Step :
Step 2: Step 1 + lowest step.
Step 3: Step 2 + Step 1 + lowest step.
Step 4: Step 3 + step 2 + step 1+ lowest step, and so on.
The smallest argument is donated by f(0) or f(1) .
The nth argument is donated by f(n). 
‚Ä¢ Example:
 fibonacci sequence
